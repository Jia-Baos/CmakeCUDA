# Shared Memory And Reduce（规约）

## 问题

1. atomicMax() 有性能瓶颈，所有的线程竞争一个变量，且该变量位于全局内存；

## 优化方案

1. 使用共享内存（比全局内存快 20 倍+）
2. Block 内先规约，减少原子操作次数

## 核心概念

### GPU 内存层次

速度从快到慢：
1. 寄存器（Registers）：最快，但容量极小，每个线程私有
2. 共享内存（Shared Memory）：很快（数个周期，在无冲突时为 1-2 个周期），48KB，Block内部共享
3. L1/L2 缓存：自动管理
4. 全局内存（Global Memory）：慢（400-800 个周期），容量大，32GB

共享内存特点：
1. 速度：比全局内存快 20-30 倍
2. 容量：每个 SM 48-164 KB（根据 GPU 型号）
3. 范围：同一个 Block 内的线程可以共享
4. 生命周期：Block 执行期间有效

声明方式

```C++
__shared__ int shared_data[256];    // 静态大小
extern __shared__ int shared_dta[]; // 动态大小
```

### ```__syncthreads``` 同步

关键规则：
1. 必须在条件语句外（所有线程都要执行到）
2. 只能同步 Block 内的线程（不能跨 Block）
3. 有性能开销，不要滥用

### 归约树（Reduction Tree）

串行归约（CPU 做法）

```C++
[3, 7, 2, 9, 1, 5, 4, 8]
max = 3
max = max(max, 7) = 7
max = max(max, 2) = 7

... 需要 7 次比较
```

并行归约树

```C++
第 0 步：[3, 7, 2, 9, 1, 5, 4, 8]
        线程 0 1 2 3 4 5 6 7

第 1 步：stride = 4，线程 0-3 活跃
        线程0：max(3, 1) = 3
        线程1：max(7, 5) = 7
        线程2：max(2, 4) = 4
        线程3：max(9, 8) = 9
        结果：[3, 7, 4, 9, -, -, -, -]

第 2 步：stride = 2，线程 0-1 活跃
        线程0：max(3, 4) = 7
        线程1：max(7, 9) = 9
        结果：[3, 9, -, -, -, -, -, -]

第 3 步：stride = 1，线程 0 活跃
        线程0：max(7, 9) = 9
        结果：[9, -, -, -, -, -, -, -]

答案在 shared_data[0] = 9
```

复杂度
- 步数：log2(N)，例如 256 个线程只需要 8 步
- 对比：串行需要 255 步
- 并行效率：极高